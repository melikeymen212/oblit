{
    "en": "h1(Protocol Deep Dive: The Architecture)\nh3(Byte-level engineering. No magic, just mathematics and precision.)\n\nOBLIT's entire design philosophy is built upon its custom packet structure. Unlike text-based protocols like HTTP that carry human-readable headers, OBLIT treats data as a **pure stream of binary bytes**. Every design decision was made with performance and efficiency in mind.\n\n![info](Understanding the protocol architecture is essential for building high-performance applications with OBLIT. This guide explains every byte, every decision, and every optimization.)!++\n\n!(line)\n\nh2(ğŸ“¦ The Packet Structure)\n\nEvery OBLIT packet consists of exactly two parts: a **fixed 3-byte header** and a **variable-length payload**.\n\n<div style=\"background:var(--sidebar); padding:25px; border-radius:12px; margin:30px 0; border:2px solid var(--border); text-align:center;\">\n<div style=\"display:flex; align-items:center; justify-content:center; gap:10px; flex-wrap:wrap; font-family:'JetBrains Mono', monospace; font-size:1.1rem; font-weight:bold;\">\n<div style=\"background:var(--primary); color:white; padding:15px 20px; border-radius:8px;\">\n<div style=\"font-size:0.8rem; opacity:0.9;\">LENGTH</div>\n<div>2 Bytes</div>\n</div>\n<div style=\"background:#22c55e; color:white; padding:15px 20px; border-radius:8px;\">\n<div style=\"font-size:0.8rem; opacity:0.9;\">OPCODE</div>\n<div>1 Byte</div>\n</div>\n<div style=\"background:var(--text-head); color:var(--bg); padding:15px 30px; border-radius:8px;\">\n<div style=\"font-size:0.8rem; opacity:0.9;\">PAYLOAD</div>\n<div>N Bytes</div>\n</div>\n</div>\n</div>\n\nh3(Header Breakdown)\n\n<div class=\"table-wrapper\"><table><thead><tr><th>Field</th><th>Size</th><th>Type</th><th>Byte Order</th><th>Range</th><th>Description</th></tr></thead><tbody><tr><td><strong>LENGTH</strong></td><td>2 Bytes</td><td><code>UInt16</code></td><td><strong>Big-Endian</strong></td><td>0 - 65,535</td><td>Payload size in bytes. This solves TCP fragmentation by telling the parser exactly how many bytes to wait for.</td></tr><tr><td><strong>OPCODE</strong></td><td>1 Byte</td><td><code>UInt8</code></td><td>N/A</td><td>0 - 255</td><td>Data type identifier. Tells the receiver how to interpret the payload (RAW=0, TXT=1, JSON=2).</td></tr></tbody></table></div>\n\n![tip](**Why Big-Endian?** Big-Endian (Network Byte Order) is the standard for network protocols. It ensures compatibility across different CPU architectures (x86, ARM, etc.). When you send data from a little-endian system to a big-endian system, using Network Byte Order guarantees both systems interpret the bytes identically.)!++\n\nh3(Visual Packet Example)\n\nLet's see what a real packet looks like in memory:\n\n<div style=\"background:#1e1e1e; padding:25px; border-radius:12px; margin:25px 0; font-family:'JetBrains Mono', monospace; font-size:0.9rem; overflow-x:auto;\">\n<div style=\"color:#4ec9b0; margin-bottom:10px;\">// Sending the string \"Hello\" as OP.TXT (opcode 1)</div>\n<div style=\"display:flex; gap:15px; align-items:center; flex-wrap:wrap; margin:15px 0;\">\n<div>\n<div style=\"color:#ce9178; font-size:0.75rem; margin-bottom:5px;\">Offset</div>\n<div style=\"color:#d4d4d4;\">00 01 02 03 04 05 06 07 08</div>\n</div>\n</div>\n<div style=\"display:flex; gap:15px; align-items:center; flex-wrap:wrap; margin:15px 0;\">\n<div>\n<div style=\"color:#4ec9b0; font-size:0.75rem; margin-bottom:5px;\">Bytes (Hex)</div>\n<div style=\"color:#d4d4d4;\">00 05 01 48 65 6C 6C 6F</div>\n</div>\n</div>\n<div style=\"display:flex; gap:15px; align-items:center; flex-wrap:wrap; margin:15px 0;\">\n<div>\n<div style=\"color:#4ec9b0; font-size:0.75rem; margin-bottom:5px;\">Meaning</div>\n<div style=\"color:#d4d4d4;\"><span style=\"background:var(--primary); padding:2px 6px; border-radius:3px;\">Length=5</span> <span style=\"background:#22c55e; padding:2px 6px; border-radius:3px;\">OP.TXT</span> <span style=\"background:var(--text-head); padding:2px 6px; border-radius:3px;\">\"Hello\"</span></div>\n</div>\n</div>\n<div style=\"border-top:1px solid #444; margin-top:20px; padding-top:20px; color:#858585; font-size:0.85rem;\">\n<strong>Breakdown:</strong><br>\nâ€¢ Bytes 0-1: <code style=\"color:#4ec9b0;\">00 05</code> = Length of 5 (Big-Endian UInt16)<br>\nâ€¢ Byte 2: <code style=\"color:#4ec9b0;\">01</code> = Opcode 1 (OP.TXT)<br>\nâ€¢ Bytes 3-7: <code style=\"color:#4ec9b0;\">48 65 6C 6C 6F</code> = UTF-8 encoding of \"Hello\"\n</div>\n</div>\n\n!(line)\n\nh2(ğŸ”¢ The OpCode System)\n\nOpCodes define how the payload should be interpreted by the receiver. OBLIT supports three data types out of the box:\n\n<div class=\"table-wrapper\"><table><thead><tr><th>OpCode</th><th>Value</th><th>Name</th><th>Payload Type</th><th>Auto-Detection</th><th>Use Case</th><th>Performance</th></tr></thead><tbody><tr><td><code>OP.RAW</code></td><td><code>0x00</code></td><td>Raw Binary</td><td><code>Buffer</code></td><td>âœ… Yes</td><td>Game coordinates, sensor data, binary streams</td><td>âš¡âš¡âš¡ Fastest</td></tr><tr><td><code>OP.TXT</code></td><td><code>0x01</code></td><td>Text</td><td><code>String</code></td><td>âœ… Yes</td><td>Chat messages, commands, log entries</td><td>âš¡âš¡ Fast</td></tr><tr><td><code>OP.JSON</code></td><td><code>0x02</code></td><td>JavaScript Object</td><td><code>Object</code></td><td>âœ… Yes</td><td>Complex structured data, configuration</td><td>âš¡ Moderate</td></tr></tbody></table></div>\n\nh3(Auto-Type Detection)\n\nOBLIT automatically detects the data type when packing:\n\n![code](const { Server, OP } = require('oblit');\nconst core = require('oblit/src/c');\n\n// OBLIT automatically detects the type:\n\n// Buffer â†’ OP.RAW (0x00)\nconst bufferPacket = core.p(OP.RAW, Buffer.from([1, 2, 3]));\n// Or you can pass Buffer directly:\nconst autoRaw = core.p(null, Buffer.from([10, 20, 30]));\n\n// String â†’ OP.TXT (0x01)\nconst textPacket = core.p(OP.TXT, \"Hello World\");\n// Or auto-detect:\nconst autoTxt = core.p(null, \"Hello\");\n\n// Object â†’ OP.JSON (0x02)\nconst jsonPacket = core.p(OP.JSON, { x: 100, y: 200 });\n// Or auto-detect:\nconst autoJson = core.p(null, { id: 42, name: \"Player\" });)!++//\n\n![info](When using the high-level API (Server/Client), you don't need to specify OpCodesâ€”OBLIT detects them automatically based on the data type you pass.)!++\n\n!(line)\n\nh2(ğŸ”„ Stream Reassembly: Solving TCP Fragmentation)\n\nTCP is a **stream protocol**, not a **message protocol**. This means data can arrive in chunks, and multiple packets can be merged into a single TCP segment. OBLIT solves this with a **stateful accumulation buffer**.\n\nh3(The Problem)\n\nImagine you send three packets:\n\n<div style=\"background:var(--sidebar); padding:20px; border-radius:8px; margin:20px 0; font-family:'JetBrains Mono', monospace;\">\nPacket 1: [H1|P1]<br>\nPacket 2: [H2|P2]<br>\nPacket 3: [H3|P3]\n</div>\n\nBut TCP might deliver them as:\n\n<div style=\"background:var(--box-warn-bg); padding:20px; border-radius:8px; margin:20px 0; font-family:'JetBrains Mono', monospace; border-left:4px solid #f97316;\">\nTCP Chunk 1: [H1|P1|H2|P2]<br>\nTCP Chunk 2: [H3|P3]\n</div>\n\nWithout reassembly, you'd try to parse incomplete packets, causing errors.\n\nh3(The Solution)\n\nOBLIT's parser maintains an internal accumulation buffer:\n\n<div style=\"background:var(--sidebar); padding:25px; border-radius:12px; margin:25px 0; text-align:center; border:2px solid var(--border);\">\n<div style=\"color:var(--text); margin-bottom:15px; font-weight:bold;\">ğŸ”µ Incoming TCP Data</div>\n<div style=\"color:var(--primary); font-size:1.5rem; margin:10px 0;\">â†“</div>\n<div style=\"background:var(--box-info-bg); padding:15px; border-radius:8px; margin:10px 0; border-left:4px solid var(--primary);\">\n<strong>ğŸ“¦ Accumulation Buffer</strong><br>\n<code style=\"background:transparent; font-size:0.9rem;\">[H1|P1|H2|P2|H3|...]</code>\n</div>\n<div style=\"color:var(--primary); font-size:1.5rem; margin:10px 0;\">â†“</div>\n<div style=\"color:var(--text); margin-top:15px; font-weight:bold;\">\n<div style=\"color:#22c55e; margin:5px 0;\">âœ… Complete Packet 1 â†’ Emit Event</div>\n<div style=\"color:#22c55e; margin:5px 0;\">âœ… Complete Packet 2 â†’ Emit Event</div>\n<div style=\"color:var(--text); margin:5px 0;\">â³ Partial Packet 3 â†’ Wait for more data</div>\n</div>\n</div>\n\nh3(Implementation Details)\n\nThe reassembly happens in a tight loop:\n\n![code](// Simplified pseudo-code of the reassembly logic\n\nlet buffer = Buffer.alloc(0); // Accumulation buffer\n\nsocket.on('data', (chunk) => {\n    // 1. Append new data to buffer\n    buffer = Buffer.concat([buffer, chunk]);\n    \n    // 2. Loop until we can't extract any complete packets\n    while (true) {\n        // 3. Check if we have enough data for a header (3 bytes minimum)\n        if (buffer.length < 3) break;\n        \n        // 4. Read the length field (first 2 bytes, Big-Endian)\n        const payloadLength = buffer.readUInt16BE(0);\n        const totalPacketSize = 3 + payloadLength; // Header + Payload\n        \n        // 5. Check if we have the complete packet\n        if (buffer.length < totalPacketSize) break; // Wait for more data\n        \n        // 6. Extract the complete packet (zero-copy using subarray)\n        const opcode = buffer.readUInt8(2);\n        const payload = buffer.subarray(3, totalPacketSize);\n        \n        // 7. Emit the complete packet\n        emit('data', payload, opcode);\n        \n        // 8. Remove processed packet from buffer\n        buffer = buffer.subarray(totalPacketSize);\n    }\n});)!++//\n\n![tip](**Zero-Copy Magic:** Notice that we use <code>buffer.subarray()</code> instead of <code>buffer.slice()</code>. <code>subarray()</code> creates a view into the existing buffer without copying any data, which is crucial for performance.)!++\n\n!(line)\n\nh2(âš¡ Performance Optimizations)\n\nh3(1. Zero-Copy Packet Extraction)\n\nInstead of copying data, OBLIT uses Buffer views:\n\n<div class=\"table-wrapper\"><table><thead><tr><th>Method</th><th>Memory Impact</th><th>Speed</th><th>Used In OBLIT</th></tr></thead><tbody><tr><td><code>Buffer.slice()</code></td><td>Allocates new memory</td><td>Slow (copy operation)</td><td>âŒ No</td></tr><tr><td><code>Buffer.subarray()</code></td><td>Creates a view (no copy)</td><td>Fast (O(1) operation)</td><td>âœ… Yes</td></tr></tbody></table></div>\n\nh3(2. Efficient Broadcasting)\n\nWhen broadcasting to multiple clients, OBLIT packs the data once and writes the same buffer to all sockets:\n\n![code](// OBLIT's broadcast implementation\nserver.bc(data) {\n    // Pack once\n    const packet = core.p(type, data);\n    \n    // Write the same buffer to all sockets (zero-copy)\n    for (const socket of connectedClients) {\n        if (!socket.destroyed) {\n            socket.write(packet); // Same buffer reference!\n        }\n    }\n})!++//\n\nh3(3. Stateful Connection Management)\n\nEach socket maintains its own accumulation buffer, preventing cross-contamination between clients.\n\n!(line)\n\nh2(ğŸ›¡ï¸ Security Features)\n\nh3(Packet Size Limiting)\n\nAny packet declaring a payload size over **64KB** causes immediate connection termination:\n\n![code](// Security check in the parser\nconst payloadLength = buffer.readUInt16BE(0);\n\nif (payloadLength > MAX_PACKET_SIZE) { // 65535 bytes\n    socket.destroy(); // Terminate connection\n    return;\n})!++//\n\nThis prevents:\n- **DoS Attacks**: Malicious clients can't flood the server with huge packets\n- **Buffer Overflow**: Memory allocation is bounded\n- **Resource Exhaustion**: Limited memory per connection\n\nh3(Buffer Overflow Protection)\n\nThe accumulation buffer has a maximum size limit. If a client tries to send fragmented packets that would exceed this limit, the connection is destroyed before memory exhaustion.\n\n!(line)\n\nh2(ğŸ“Š Packet Size Comparison)\n\nHere's how OBLIT compares to other protocols for the same data:\n\n<div class=\"table-wrapper\"><table><thead><tr><th>Data</th><th>JSON</th><th>OBLIT (TXT)</th><th>OBLIT (RAW)</th><th>Savings</th></tr></thead><tbody><tr><td><code>\"Hello\"</code></td><td>7 bytes</td><td>8 bytes (3B header + 5B payload)</td><td>N/A</td><td>-14% (overhead)</td></tr><tr><td><code>{x:100,y:200}</code></td><td>17 bytes</td><td>20 bytes (JSON)</td><td>8 bytes (binary)</td><td>+53% (binary)</td></tr><tr><td><code>Player position (id,x,y)</code></td><td>28 bytes</td><td>31 bytes (JSON)</td><td>9 bytes (binary)</td><td>+68% (binary)</td></tr><tr><td><strong>Average (50k messages)</strong></td><td><strong>1318 KB</strong></td><td><strong>N/A</strong></td><td><strong>585 KB</strong></td><td><strong>+55%</strong></td></tr></tbody></table></div>\n\n![info](The key insight: For small text messages, OBLIT has a 3-byte overhead. But for structured data (like game coordinates), using binary packing provides massive savings.)!++\n\n!(line)\n\nh2(ğŸ¯ Key Takeaways)\n\n1. **3-byte header** is the smallest possible for variable-length packets\n2. **Big-Endian** ensures cross-platform compatibility\n3. **Stream reassembly** solves TCP fragmentation automatically\n4. **Zero-copy parsing** maximizes performance\n5. **Auto-type detection** makes the API simple and intuitive\n6. **Size limits** prevent DoS attacks and memory exhaustion\n\n![tip](Want to see this in action? Check out the **[Server API](#!/server_api)** and **[Client API](#!/client_api)** pages for code examples using the protocol.)!++",
    "tr": "h1(Protokol DetaylarÄ±: Mimari)\nh3(Bayt seviyesinde mÃ¼hendislik. Sihir yok, sadece matematik ve kesinlik.)\n\nOBLIT'in tÃ¼m tasarÄ±m felsefesi, Ã¶zel paket yapÄ±sÄ± Ã¼zerine kuruludur. HTTP gibi insan tarafÄ±ndan okunabilir baÅŸlÄ±klar taÅŸÄ±yan metin tabanlÄ± protokollerin aksine, OBLIT veriyi **saf bir binary bayt akÄ±ÅŸÄ±** olarak ele alÄ±r. Her tasarÄ±m kararÄ± performans ve verimlilik gÃ¶z Ã¶nÃ¼nde bulundurularak alÄ±nmÄ±ÅŸtÄ±r.\n\n![info](Protokol mimarisini anlamak, OBLIT ile yÃ¼ksek performanslÄ± uygulamalar oluÅŸturmak iÃ§in gereklidir. Bu kÄ±lavuz her baytÄ±, her kararÄ± ve her optimizasyonu aÃ§Ä±klar.)!++\n\n!(line)\n\nh2(ğŸ“¦ Paket YapÄ±sÄ±)\n\nHer OBLIT paketi tam olarak iki bÃ¶lÃ¼mden oluÅŸur: **sabit 3-byte baÅŸlÄ±k** ve **deÄŸiÅŸken uzunlukta yÃ¼k**.\n\n<div style=\"background:var(--sidebar); padding:25px; border-radius:12px; margin:30px 0; border:2px solid var(--border); text-align:center;\">\n<div style=\"display:flex; align-items:center; justify-content:center; gap:10px; flex-wrap:wrap; font-family:'JetBrains Mono', monospace; font-size:1.1rem; font-weight:bold;\">\n<div style=\"background:var(--primary); color:white; padding:15px 20px; border-radius:8px;\">\n<div style=\"font-size:0.8rem; opacity:0.9;\">UZUNLUK</div>\n<div>2 Bayt</div>\n</div>\n<div style=\"background:#22c55e; color:white; padding:15px 20px; border-radius:8px;\">\n<div style=\"font-size:0.8rem; opacity:0.9;\">OPCODE</div>\n<div>1 Bayt</div>\n</div>\n<div style=\"background:var(--text-head); color:var(--bg); padding:15px 30px; border-radius:8px;\">\n<div style=\"font-size:0.8rem; opacity:0.9;\">YÃœK</div>\n<div>N Bayt</div>\n</div>\n</div>\n</div>\n\nh3(BaÅŸlÄ±k DetaylarÄ±)\n\n<div class=\"table-wrapper\"><table><thead><tr><th>Alan</th><th>Boyut</th><th>Tip</th><th>Bayt SÄ±rasÄ±</th><th>AralÄ±k</th><th>AÃ§Ä±klama</th></tr></thead><tbody><tr><td><strong>UZUNLUK</strong></td><td>2 Bayt</td><td><code>UInt16</code></td><td><strong>Big-Endian</strong></td><td>0 - 65,535</td><td>YÃ¼kÃ¼n bayt cinsinden boyutu. Bu, ayrÄ±ÅŸtÄ±rÄ±cÄ±ya tam olarak kaÃ§ bayt beklenmesi gerektiÄŸini sÃ¶yleyerek TCP parÃ§alanmasÄ±nÄ± Ã§Ã¶zer.</td></tr><tr><td><strong>OPCODE</strong></td><td>1 Bayt</td><td><code>UInt8</code></td><td>Yok</td><td>0 - 255</td><td>Veri tipi tanÄ±mlayÄ±cÄ±sÄ±. AlÄ±cÄ±ya yÃ¼kÃ¼n nasÄ±l yorumlanacaÄŸÄ±nÄ± sÃ¶yler (RAW=0, TXT=1, JSON=2).</td></tr></tbody></table></div>\n\n![tip](**Neden Big-Endian?** Big-Endian (AÄŸ Bayt SÄ±rasÄ±) aÄŸ protokolleri iÃ§in standarttÄ±r. FarklÄ± CPU mimarileri (x86, ARM, vb.) arasÄ±nda uyumluluÄŸu garanti eder. KÃ¼Ã§Ã¼k endian bir sistemden bÃ¼yÃ¼k endian bir sisteme veri gÃ¶nderdiÄŸinizde, AÄŸ Bayt SÄ±rasÄ± kullanmak her iki sistemin baytlarÄ± aynÄ± ÅŸekilde yorumlamasÄ±nÄ± garanti eder.)!++\n\nh3(GÃ¶rsel Paket Ã–rneÄŸi)\n\nGerÃ§ek bir paketin bellekte nasÄ±l gÃ¶rÃ¼ndÃ¼ÄŸÃ¼nÃ¼ gÃ¶relim:\n\n<div style=\"background:#1e1e1e; padding:25px; border-radius:12px; margin:25px 0; font-family:'JetBrains Mono', monospace; font-size:0.9rem; overflow-x:auto;\">\n<div style=\"color:#4ec9b0; margin-bottom:10px;\">// \"Hello\" stringini OP.TXT (opcode 1) olarak gÃ¶nderme</div>\n<div style=\"display:flex; gap:15px; align-items:center; flex-wrap:wrap; margin:15px 0;\">\n<div>\n<div style=\"color:#ce9178; font-size:0.75rem; margin-bottom:5px;\">Offset</div>\n<div style=\"color:#d4d4d4;\">00 01 02 03 04 05 06 07 08</div>\n</div>\n</div>\n<div style=\"display:flex; gap:15px; align-items:center; flex-wrap:wrap; margin:15px 0;\">\n<div>\n<div style=\"color:#4ec9b0; font-size:0.75rem; margin-bottom:5px;\">Baytlar (Hex)</div>\n<div style=\"color:#d4d4d4;\">00 05 01 48 65 6C 6C 6F</div>\n</div>\n</div>\n<div style=\"display:flex; gap:15px; align-items:center; flex-wrap:wrap; margin:15px 0;\">\n<div>\n<div style=\"color:#4ec9b0; font-size:0.75rem; margin-bottom:5px;\">Anlam</div>\n<div style=\"color:#d4d4d4;\"><span style=\"background:var(--primary); padding:2px 6px; border-radius:3px;\">Uzunluk=5</span> <span style=\"background:#22c55e; padding:2px 6px; border-radius:3px;\">OP.TXT</span> <span style=\"background:var(--text-head); padding:2px 6px; border-radius:3px;\">\"Hello\"</span></div>\n</div>\n</div>\n<div style=\"border-top:1px solid #444; margin-top:20px; padding-top:20px; color:#858585; font-size:0.85rem;\">\n<strong>AyrÄ±ntÄ±lar:</strong><br>\nâ€¢ Bayt 0-1: <code style=\"color:#4ec9b0;\">00 05</code> = 5 uzunluÄŸu (Big-Endian UInt16)<br>\nâ€¢ Bayt 2: <code style=\"color:#4ec9b0;\">01</code> = Opcode 1 (OP.TXT)<br>\nâ€¢ Bayt 3-7: <code style=\"color:#4ec9b0;\">48 65 6C 6C 6F</code> = \"Hello\"'nun UTF-8 kodlamasÄ±\n</div>\n</div>\n\n!(line)\n\nh2(ğŸ”¢ OpCode Sistemi)\n\nOpCode'lar, yÃ¼kÃ¼n alÄ±cÄ± tarafÄ±ndan nasÄ±l yorumlanmasÄ± gerektiÄŸini tanÄ±mlar. OBLIT varsayÄ±lan olarak Ã¼Ã§ veri tipini destekler:\n\n<div class=\"table-wrapper\"><table><thead><tr><th>OpCode</th><th>DeÄŸer</th><th>Ä°sim</th><th>YÃ¼k Tipi</th><th>Otomatik Tespit</th><th>KullanÄ±m AlanÄ±</th><th>Performans</th></tr></thead><tbody><tr><td><code>OP.RAW</code></td><td><code>0x00</code></td><td>Ham Binary</td><td><code>Buffer</code></td><td>âœ… Evet</td><td>Oyun koordinatlarÄ±, sensÃ¶r verisi, binary akÄ±ÅŸlar</td><td>âš¡âš¡âš¡ En HÄ±zlÄ±</td></tr><tr><td><code>OP.TXT</code></td><td><code>0x01</code></td><td>Metin</td><td><code>String</code></td><td>âœ… Evet</td><td>Sohbet mesajlarÄ±, komutlar, log kayÄ±tlarÄ±</td><td>âš¡âš¡ HÄ±zlÄ±</td></tr><tr><td><code>OP.JSON</code></td><td><code>0x02</code></td><td>JavaScript Nesnesi</td><td><code>Object</code></td><td>âœ… Evet</td><td>KarmaÅŸÄ±k yapÄ±sal veri, yapÄ±landÄ±rma</td><td>âš¡ Orta</td></tr></tbody></table></div>\n\nh3(Otomatik Tip Tespiti)\n\nOBLIT, paketleme yaparken veri tipini otomatik olarak tespit eder:\n\n![code](const { Server, OP } = require('oblit');\nconst core = require('oblit/src/c');\n\n// OBLIT otomatik olarak tipi tespit eder:\n\n// Buffer â†’ OP.RAW (0x00)\nconst bufferPacket = core.p(OP.RAW, Buffer.from([1, 2, 3]));\n// Veya doÄŸrudan Buffer geÃ§irebilirsiniz:\nconst autoRaw = core.p(null, Buffer.from([10, 20, 30]));\n\n// String â†’ OP.TXT (0x01)\nconst textPacket = core.p(OP.TXT, \"Merhaba DÃ¼nya\");\n// Veya otomatik tespit:\nconst autoTxt = core.p(null, \"Merhaba\");\n\n// Object â†’ OP.JSON (0x02)\nconst jsonPacket = core.p(OP.JSON, { x: 100, y: 200 });\n// Veya otomatik tespit:\nconst autoJson = core.p(null, { id: 42, name: \"Oyuncu\" });)!++//\n\n![info](YÃ¼ksek seviye API (Server/Client) kullanÄ±rken OpCode belirtmenize gerek yokâ€”OBLIT, geÃ§irdiÄŸiniz veri tipine gÃ¶re bunlarÄ± otomatik olarak tespit eder.)!++\n\n!(line)\n\nh2(ğŸ”„ AkÄ±ÅŸ Yeniden BirleÅŸtirme: TCP ParÃ§alanmasÄ±nÄ± Ã‡Ã¶zme)\n\nTCP bir **akÄ±ÅŸ protokolÃ¼dÃ¼r**, **mesaj protokolÃ¼ deÄŸildir**. Bu, verinin parÃ§alar halinde gelebileceÄŸi ve birden Ã§ok paketin tek bir TCP segmentine birleÅŸtirilebileceÄŸi anlamÄ±na gelir. OBLIT bunu **durum bilgisi olan bir biriktirme tamponu** ile Ã§Ã¶zer.\n\nh3(Sorun)\n\nÃœÃ§ paket gÃ¶nderdiÄŸinizi hayal edin:\n\n<div style=\"background:var(--sidebar); padding:20px; border-radius:8px; margin:20px 0; font-family:'JetBrains Mono', monospace;\">\nPaket 1: [H1|P1]<br>\nPaket 2: [H2|P2]<br>\nPaket 3: [H3|P3]\n</div>\n\nAncak TCP bunlarÄ± ÅŸu ÅŸekilde teslim edebilir:\n\n<div style=\"background:var(--box-warn-bg); padding:20px; border-radius:8px; margin:20px 0; font-family:'JetBrains Mono', monospace; border-left:4px solid #f97316;\">\nTCP ParÃ§a 1: [H1|P1|H2|P2]<br>\nTCP ParÃ§a 2: [H3|P3]\n</div>\n\nYeniden birleÅŸtirme olmadan, eksik paketleri ayrÄ±ÅŸtÄ±rmaya Ã§alÄ±ÅŸÄ±rsÄ±nÄ±z ve bu hatalara neden olur.\n\nh3(Ã‡Ã¶zÃ¼m)\n\nOBLIT'in ayrÄ±ÅŸtÄ±rÄ±cÄ±sÄ± dahili bir biriktirme tamponu tutar:\n\n<div style=\"background:var(--sidebar); padding:25px; border-radius:12px; margin:25px 0; text-align:center; border:2px solid var(--border);\">\n<div style=\"color:var(--text); margin-bottom:15px; font-weight:bold;\">ğŸ”µ Gelen TCP Verisi</div>\n<div style=\"color:var(--primary); font-size:1.5rem; margin:10px 0;\">â†“</div>\n<div style=\"background:var(--box-info-bg); padding:15px; border-radius:8px; margin:10px 0; border-left:4px solid var(--primary);\">\n<strong>ğŸ“¦ Biriktirme Tamponu</strong><br>\n<code style=\"background:transparent; font-size:0.9rem;\">[H1|P1|H2|P2|H3|...]</code>\n</div>\n<div style=\"color:var(--primary); font-size:1.5rem; margin:10px 0;\">â†“</div>\n<div style=\"color:var(--text); margin-top:15px; font-weight:bold;\">\n<div style=\"color:#22c55e; margin:5px 0;\">âœ… Tam Paket 1 â†’ Olay YayÄ±nla</div>\n<div style=\"color:#22c55e; margin:5px 0;\">âœ… Tam Paket 2 â†’ Olay YayÄ±nla</div>\n<div style=\"color:var(--text); margin:5px 0;\">â³ KÄ±smi Paket 3 â†’ Daha fazla veri bekle</div>\n</div>\n</div>\n\nh3(Uygulama DetaylarÄ±)\n\nYeniden birleÅŸtirme sÄ±kÄ± bir dÃ¶ngÃ¼de gerÃ§ekleÅŸir:\n\n![code](// Yeniden birleÅŸtirme mantÄ±ÄŸÄ±nÄ±n basitleÅŸtirilmiÅŸ sÃ¶zde kodu\n\nlet buffer = Buffer.alloc(0); // Biriktirme tamponu\n\nsocket.on('data', (chunk) => {\n    // 1. Yeni veriyi tampona ekle\n    buffer = Buffer.concat([buffer, chunk]);\n    \n    // 2. ArtÄ±k tam paket Ã§Ä±karamayÄ±ncaya kadar dÃ¶ngÃ¼\n    while (true) {\n        // 3. BaÅŸlÄ±k iÃ§in yeterli veri var mÄ± kontrol et (minimum 3 bayt)\n        if (buffer.length < 3) break;\n        \n        // 4. Uzunluk alanÄ±nÄ± oku (ilk 2 bayt, Big-Endian)\n        const payloadLength = buffer.readUInt16BE(0);\n        const totalPacketSize = 3 + payloadLength; // BaÅŸlÄ±k + YÃ¼k\n        \n        // 5. Tam paketi aldÄ±k mÄ± kontrol et\n        if (buffer.length < totalPacketSize) break; // Daha fazla veri bekle\n        \n        // 6. Tam paketi Ã§Ä±kar (subarray kullanarak sÄ±fÄ±r kopyalama)\n        const opcode = buffer.readUInt8(2);\n        const payload = buffer.subarray(3, totalPacketSize);\n        \n        // 7. Tam paketi yayÄ±nla\n        emit('data', payload, opcode);\n        \n        // 8. Ä°ÅŸlenen paketi tampondan Ã§Ä±kar\n        buffer = buffer.subarray(totalPacketSize);\n    }\n});)!++//\n\n![tip](**SÄ±fÄ±r Kopyalama Sihri:** <code>buffer.slice()</code> yerine <code>buffer.subarray()</code> kullandÄ±ÄŸÄ±mÄ±za dikkat edin. <code>subarray()</code> herhangi bir veri kopyalamadan mevcut tampon iÃ§inde bir gÃ¶rÃ¼nÃ¼m oluÅŸturur, bu performans iÃ§in Ã§ok Ã¶nemlidir.)!++\n\n!(line)\n\nh2(âš¡ Performans OptimizasyonlarÄ±)\n\nh3(1. SÄ±fÄ±r Kopyalama Paket Ã‡Ä±karma)\n\nVeri kopyalamak yerine, OBLIT Buffer gÃ¶rÃ¼nÃ¼mlerini kullanÄ±r:\n\n<div class=\"table-wrapper\"><table><thead><tr><th>Metod</th><th>Bellek Etkisi</th><th>HÄ±z</th><th>OBLIT'te KullanÄ±lÄ±yor</th></tr></thead><tbody><tr><td><code>Buffer.slice()</code></td><td>Yeni bellek ayÄ±rÄ±r</td><td>YavaÅŸ (kopyalama iÅŸlemi)</td><td>âŒ HayÄ±r</td></tr><tr><td><code>Buffer.subarray()</code></td><td>GÃ¶rÃ¼nÃ¼m oluÅŸturur (kopya yok)</td><td>HÄ±zlÄ± (O(1) iÅŸlemi)</td><td>âœ… Evet</td></tr></tbody></table></div>\n\nh3(2. Verimli YayÄ±nlama)\n\nBirden Ã§ok istemciye yayÄ±nlarken, OBLIT veriyi bir kez paketler ve aynÄ± tamponu tÃ¼m soketlere yazar:\n\n![code](// OBLIT'in yayÄ±nlama uygulamasÄ±\nserver.bc(data) {\n    // Bir kez paketle\n    const packet = core.p(type, data);\n    \n    // AynÄ± tamponu tÃ¼m soketlere yaz (sÄ±fÄ±r kopyalama)\n    for (const socket of connectedClients) {\n        if (!socket.destroyed) {\n            socket.write(packet); // AynÄ± buffer referansÄ±!\n        }\n    }\n})!++//\n\nh3(3. Durum Bilgisi Olan BaÄŸlantÄ± YÃ¶netimi)\n\nHer soket kendi biriktirme tamponunu tutar, bu da istemciler arasÄ±nda Ã§apraz kontaminasyonu Ã¶nler.\n\n!(line)\n\nh2(ğŸ›¡ï¸ GÃ¼venlik Ã–zellikleri)\n\nh3(Paket Boyutu SÄ±nÄ±rlama)\n\n**64KB**'tan fazla yÃ¼k boyutu beyan eden her paket, anÄ±nda baÄŸlantÄ± sonlandÄ±rmasÄ±na neden olur:\n\n![code](// AyrÄ±ÅŸtÄ±rÄ±cÄ±daki gÃ¼venlik kontrolÃ¼\nconst payloadLength = buffer.readUInt16BE(0);\n\nif (payloadLength > MAX_PACKET_SIZE) { // 65535 bayt\n    socket.destroy(); // BaÄŸlantÄ±yÄ± sonlandÄ±r\n    return;\n})!++//\n\nBu ÅŸunlarÄ± Ã¶nler:\n- **DoS SaldÄ±rÄ±larÄ±**: KÃ¶tÃ¼ niyetli istemciler sunucuyu bÃ¼yÃ¼k paketlerle dolduramaz\n- **Buffer TaÅŸmasÄ±**: Bellek ayrÄ±mÄ± sÄ±nÄ±rlÄ±dÄ±r\n- **Kaynak TÃ¼kenmesi**: BaÄŸlantÄ± baÅŸÄ±na sÄ±nÄ±rlÄ± bellek\n\nh3(Buffer TaÅŸmasÄ± KorumasÄ±)\n\nBiriktirme tamponunun maksimum boyut sÄ±nÄ±rÄ± vardÄ±r. Bir istemci bu sÄ±nÄ±rÄ± aÅŸacak parÃ§alanmÄ±ÅŸ paketler gÃ¶ndermeye Ã§alÄ±ÅŸÄ±rsa, bellek tÃ¼kenmeden Ã¶nce baÄŸlantÄ± sonlandÄ±rÄ±lÄ±r.\n\n!(line)\n\nh2(ğŸ“Š Paket Boyutu KarÅŸÄ±laÅŸtÄ±rmasÄ±)\n\nOBLIT'in aynÄ± veri iÃ§in diÄŸer protokollerle nasÄ±l karÅŸÄ±laÅŸtÄ±rÄ±ldÄ±ÄŸÄ±:\n\n<div class=\"table-wrapper\"><table><thead><tr><th>Veri</th><th>JSON</th><th>OBLIT (TXT)</th><th>OBLIT (RAW)</th><th>Tasarruf</th></tr></thead><tbody><tr><td><code>\"Hello\"</code></td><td>7 bayt</td><td>8 bayt (3B baÅŸlÄ±k + 5B yÃ¼k)</td><td>N/A</td><td>-14% (ek yÃ¼k)</td></tr><tr><td><code>{x:100,y:200}</code></td><td>17 bayt</td><td>20 bayt (JSON)</td><td>8 bayt (binary)</td><td>+53% (binary)</td></tr><tr><td><code>Oyuncu konumu (id,x,y)</code></td><td>28 bayt</td><td>31 bayt (JSON)</td><td>9 bayt (binary)</td><td>+68% (binary)</td></tr><tr><td><strong>Ortalama (50k mesaj)</strong></td><td><strong>1318 KB</strong></td><td><strong>N/A</strong></td><td><strong>585 KB</strong></td><td><strong>+55%</strong></td></tr></tbody></table></div>\n\n![info](Anahtar iÃ§gÃ¶rÃ¼: KÃ¼Ã§Ã¼k metin mesajlarÄ± iÃ§in OBLIT'in 3 baytlÄ±k bir ek yÃ¼kÃ¼ vardÄ±r. Ancak yapÄ±landÄ±rÄ±lmÄ±ÅŸ veriler (oyun koordinatlarÄ± gibi) iÃ§in binary paketleme kullanmak bÃ¼yÃ¼k tasarruflar saÄŸlar.)!++\n\n!(line)\n\nh2(ğŸ¯ Anahtar Noktalar)\n\n1. **3-byte baÅŸlÄ±k** deÄŸiÅŸken uzunluklu paketler iÃ§in mÃ¼mkÃ¼n olan en kÃ¼Ã§Ã¼ktÃ¼r\n2. **Big-Endian** platformlar arasÄ± uyumluluÄŸu garanti eder\n3. **AkÄ±ÅŸ yeniden birleÅŸtirme** TCP parÃ§alanmasÄ±nÄ± otomatik olarak Ã§Ã¶zer\n4. **SÄ±fÄ±r kopyalama ayrÄ±ÅŸtÄ±rma** performansÄ± maksimize eder\n5. **Otomatik tip tespiti** API'yi basit ve sezgisel yapar\n6. **Boyut sÄ±nÄ±rlarÄ±** DoS saldÄ±rÄ±larÄ±nÄ± ve bellek tÃ¼kenmesini Ã¶nler\n\n![tip](Bunu uygulamada gÃ¶rmek ister misiniz? ProtokolÃ¼ kullanan kod Ã¶rnekleri iÃ§in **[Sunucu API](#!/server_api)** ve **[Ä°stemci API](#!/client_api)** sayfalarÄ±na bakÄ±n.)!++"
}
