{
    "en": "h1(Memory & Stream Management)\nh3(Controlling the chaos of TCP streams.)\n\nTCP is a firehose, not a conveyor belt. It guarantees that bytes arrive in order, but not in neat packages. Oblit acts as the \"bottling factory\" for this firehose.\n\n<div style=\"background:var(--sidebar); padding:20px; border-radius:8px; margin: 30px 0; border:1px solid var(--border); text-align: center; font-family: 'JetBrains Mono';\">\n    <code style=\"background:transparent; color: var(--text);\">[CHUNK 1] [CHUNK 2]</code>\n    <br>↓<br>\n    <strong style=\"color: var(--primary);\">ACCUMULATION BUFFER (Internal)</strong>\n    <br>↓<br>\n    <code style=\"background:transparent; color: var(--text);\">[PACKET 1] [PACKET 2] [REMAINDER...]</code>\n</div>\n\nThis process, called **Stream Reassembly**, happens in a tight `while` loop inside the `data` event listener. Oblit reads the LENGTH header, waits for enough data to accumulate, processes a full packet, and then loops again on the remaining buffer. \n\nh2(The Zero-Copy Philosophy)\nTo avoid triggering the Node.js Garbage Collector (which causes stutters), Oblit never allocates new memory for parsing incoming packets. It uses **`Buffer.subarray()`**, which creates a lightweight \"view\" into the existing accumulation buffer without copying any data. This is the key to handling tens of thousands of messages per second without increasing RAM usage.\n\n![dang](If an attacker tries to flood the server with an oversized packet, the accumulation buffer's size limit is hit and the connection is destroyed before any major memory allocation occurs.)!++",
    "tr": "h1(Bellek ve Akış Yönetimi)\nh3(TCP akışlarının kaosunu kontrol etmek.)\n\nTCP, bir taşıma bandı değil, bir yangın hortumudur. Baytların sırayla geleceğini garanti eder, ancak düzgün paketler halinde değil. Oblit, bu yangın hortumu için \"şişeleme fabrikası\" görevi görür.\n\n<div style=\"background:var(--sidebar); padding:20px; border-radius:8px; margin: 30px 0; border:1px solid var(--border); text-align: center; font-family: 'JetBrains Mono';\">\n    <code style=\"background:transparent; color: var(--text);\">[PARÇA 1] [PARÇA 2]</code>\n    <br>↓<br>\n    <strong style=\"color: var(--primary);\">BİRİKTİRME TAMPONU (Dahili)</strong>\n    <br>↓<br>\n    <code style=\"background:transparent; color: var(--text);\">[PAKET 1] [PAKET 2] [KALAN...]</code>\n</div>\n\nBu süreç, **Akışın Yeniden Birleştirilmesi** olarak adlandırılır ve `data` olay dinleyicisi içindeki sıkı bir `while` döngüsünde gerçekleşir. Oblit, UZUNLUK başlığını okur, yeterli verinin birikmesini bekler, tam bir paketi işler ve sonra kalan tampon üzerinde tekrar döngüye girer.\n\nh2(Sıfır Kopyalama Felsefesi)\nNode.js Çöp Toplayıcısını (donmalara neden olur) tetiklemekten kaçınmak için, Oblit gelen paketleri ayrıştırırken asla yeni bellek ayırmaz. **`Buffer.subarray()`** kullanır, bu da herhangi bir veri kopyalamadan mevcut biriktirme tamponu içinde hafif bir \"pencere\" oluşturur. Bu, RAM kullanımını artırmadan saniyede on binlerce mesajı işlemenin anahtarıdır.\n\n![dang](Eğer bir saldırgan sunucuyu aşırı büyük bir paketle doldurmaya çalışırsa, biriktirme tamponunun boyut sınırına ulaşılır ve büyük bir bellek ayrımı gerçekleşmeden önce bağlantı yok edilir.)!++"
}